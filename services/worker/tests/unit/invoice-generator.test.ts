/**
 * Invoice generator tests
 * Tests for invoice generation and Firestore saving
 */

import { generateInvoice } from '../../src/services/invoice-generator';
import type { InvoiceSession } from '../../../../shared/types';

// Mock dependencies
const mockSet = jest.fn();
const mockDoc = jest.fn(() => ({
  set: mockSet,
}));
const mockCollection = jest.fn(() => ({
  doc: mockDoc,
}));

const mockBucket = jest.fn(() => ({
  file: jest.fn(() => ({
    save: jest.fn().mockResolvedValue(undefined),
    publicUrl: jest.fn(() => 'https://storage.googleapis.com/test-bucket/test.pdf'),
  })),
}));

const mockStorage = jest.fn(() => ({
  bucket: mockBucket,
}));

const mockGeneratePDF = jest.fn().mockResolvedValue(Buffer.from('fake-pdf-content'));
const mockGetNextInvoiceNumber = jest.fn().mockResolvedValue('202610');
const mockAppendGeneratedInvoiceRow = jest.fn().mockResolvedValue(undefined);

jest.mock('@google-cloud/firestore', () => {
  return {
    Firestore: jest.fn(() => ({
      collection: mockCollection,
    })),
    FieldValue: {
      serverTimestamp: jest.fn(() => new Date('2026-01-17')),
    },
    Timestamp: {
      fromDate: jest.fn((date) => date),
    },
  };
});

jest.mock('@google-cloud/storage', () => {
  return {
    Storage: jest.fn(() => mockStorage()),
  };
});

jest.mock('../../src/services/invoice-generator/pdf.generator', () => ({
  generateInvoicePDFWithConfig: jest.fn(() => mockGeneratePDF()),
}));

jest.mock('../../src/services/invoice-generator/counter.service', () => ({
  getNextInvoiceNumber: jest.fn(() => mockGetNextInvoiceNumber()),
}));

jest.mock('../../src/services/business-config/config.service', () => ({
  getBusinessConfig: jest.fn(),
  getLogoBase64: jest.fn(),
}));

jest.mock('../../src/services/sheets.service', () => ({
  appendGeneratedInvoiceRow: jest.fn(() => mockAppendGeneratedInvoiceRow()),
}));

jest.mock('../../src/config', () => ({
  getConfig: jest.fn(() => ({
    generatedInvoicesBucket: 'test-bucket',
  })),
}));

// Import the mocked modules to set up the mocks
import * as configService from '../../src/services/business-config/config.service';

describe('Invoice Generator', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Set up the mocks to return the mock values
    (configService.getBusinessConfig as jest.Mock).mockResolvedValue({
      business: {
        name: 'Test Business',
        address: '123 Test St',
        phone: '123-456-7890',
        taxId: '123456789',
        taxStatus: 'עוסק מורשה',
        email: 'test@example.com',
      },
      invoice: {
        footer: 'Thank you!',
        digitalSignatureText: 'Signed',
        generatedByText: 'Generated by',
      },
    });
    (configService.getLogoBase64 as jest.Mock).mockResolvedValue(null);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('generateInvoice', () => {
    const userId = 123456;
    const username = 'testuser';
    const chatId = 789012;

    const baseSession: InvoiceSession = {
      status: 'confirming',
      documentType: 'invoice',
      customerName: 'John Doe',
      description: 'Test invoice',
      amount: 1000,
      paymentMethod: 'מזומן',
      date: '2026-01-17',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    it('should successfully generate invoice without customerTaxId', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        // customerTaxId is undefined
      };

      const result = await generateInvoice(session, userId, username, chatId);

      expect(result.invoiceNumber).toBe('202610');
      expect(result.pdfBuffer).toBeInstanceOf(Buffer);
      expect(result.pdfUrl).toContain('storage.googleapis.com');

      // Verify Firestore save was called with per-customer document ID
      expect(mockCollection).toHaveBeenCalledWith('generated_invoices');
      expect(mockDoc).toHaveBeenCalledWith('chat_789012_202610');
      expect(mockSet).toHaveBeenCalled();

      // Verify customerTaxId is NOT in the Firestore record
      const firestoreRecord = mockSet.mock.calls[0][0];
      expect(firestoreRecord).not.toHaveProperty('customerTaxId');
      expect(firestoreRecord.customerName).toBe('John Doe');
      expect(firestoreRecord.amount).toBe(1000);
    });

    it('should successfully generate invoice with customerTaxId', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        customerTaxId: '123456789',
      };

      const result = await generateInvoice(session, userId, username, chatId);

      expect(result.invoiceNumber).toBe('202610');
      expect(result.pdfBuffer).toBeInstanceOf(Buffer);

      // Verify Firestore save was called
      expect(mockSet).toHaveBeenCalled();

      // Verify customerTaxId IS in the Firestore record
      const firestoreRecord = mockSet.mock.calls[0][0];
      expect(firestoreRecord).toHaveProperty('customerTaxId');
      expect(firestoreRecord.customerTaxId).toBe('123456789');
    });

    it('should not include customerTaxId when explicitly undefined', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        customerTaxId: undefined,
      };

      await generateInvoice(session, userId, username, chatId);

      // Verify customerTaxId is NOT in the Firestore record
      const firestoreRecord = mockSet.mock.calls[0][0];
      expect(firestoreRecord).not.toHaveProperty('customerTaxId');
    });

    it('should handle invoice_receipt document type', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        documentType: 'invoice_receipt',
        customerTaxId: '987654321',
      };

      await generateInvoice(session, userId, username, chatId);

      const firestoreRecord = mockSet.mock.calls[0][0];
      expect(firestoreRecord.documentType).toBe('invoice_receipt');
      expect(firestoreRecord.customerTaxId).toBe('987654321');
    });

    it('should throw error when session is incomplete', async () => {
      const incompleteSession: InvoiceSession = {
        status: 'confirming',
        documentType: 'invoice',
        // Missing required fields
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await expect(generateInvoice(incompleteSession, userId, username, chatId)).rejects.toThrow(
        'Invoice session is incomplete'
      );
    });

    it('should generate invoices with per-customer document IDs', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        customerTaxId: '123456789',
      };

      // Generate for chatId 789012
      await generateInvoice(session, userId, username, chatId);

      // Verify first customer's document ID
      expect(mockDoc).toHaveBeenCalledWith('chat_789012_202610');

      // Verify storage path includes chatId
      const firestoreRecord = mockSet.mock.calls[0][0];
      expect(firestoreRecord.storagePath).toBe('789012/2026/202610.pdf');
      expect(firestoreRecord.storageUrl).toContain('789012/2026/202610.pdf');
    });

    it('should allow different customers to have same invoice number without collision', async () => {
      const session: InvoiceSession = {
        ...baseSession,
        customerTaxId: '123456789',
      };

      // Customer A generates first invoice
      const chatIdA = -1001111111;
      await generateInvoice(session, userId, username, chatIdA);

      // Verify Customer A got invoice 202610 with their document ID
      expect(mockDoc).toHaveBeenCalledWith('chat_-1001111111_202610');
      const recordA = mockSet.mock.calls[0][0];
      expect(recordA.invoiceNumber).toBe('202610');
      expect(recordA.storagePath).toBe('-1001111111/2026/202610.pdf');

      // Customer B generates their first invoice (should ALSO get 202610)
      const chatIdB = -1002222222;
      await generateInvoice(session, userId, username, chatIdB);

      // Verify Customer B ALSO got invoice 202610 but with THEIR document ID
      expect(mockDoc).toHaveBeenCalledWith('chat_-1002222222_202610');
      const recordB = mockSet.mock.calls[1][0];
      expect(recordB.invoiceNumber).toBe('202610');
      expect(recordB.storagePath).toBe('-1002222222/2026/202610.pdf');

      // Verify no collision - different document IDs and storage paths
      expect(recordA.storagePath).not.toBe(recordB.storagePath);
      expect(mockDoc).toHaveBeenCalledTimes(2);
      expect(mockDoc).toHaveBeenNthCalledWith(1, 'chat_-1001111111_202610');
      expect(mockDoc).toHaveBeenNthCalledWith(2, 'chat_-1002222222_202610');
    });
  });
});
